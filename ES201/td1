Pour se connecter en ssh : ssh -Xt hubert@relais.ensta.fr salle


exercice 1:

1) La loi d'Amdahl s'écrit speedup_total = ( t1 + t2 ) / ( t1 + t2 / speedup_partiel ) = 1 / ( ( 1 - p ) + p / s )
Ici, p = 0.5 et s = 10, donc le speedup vaut 5/3 = 1.67


exercice 2:

1) On applique la loi d'Amdahl avec les paramètres p = 0.2 et s = 4 pour obtenir un speedup de 1.18

2) On applique la loi d'Amdahl avec les paramètres p = 0.5 et s = 2 pour obtenir un speedup de 1.33

1) On généralise la loi d'Amdahl en considérant des speedups différents pour des parties différentes.
s_tot = ( t1 + t2 + t3 ) / ( t1 + t2 / s_part1 + t3 / s_part2 ) = 1 / ( ( 1 - p1 - p2 ) + p1 / s1 + p2 / s2 )
On trouve alors un speedup de 1.67


exercice 3:

sim: ** starting performance simulation **

sim: ** simulation statistics **
sim_num_insn                   7834 # total number of instructions committed
sim_num_refs                   4175 # total number of loads and stores committed
sim_num_loads                   706 # total number of loads committed
sim_num_stores            3469.0000 # total number of stores committed
sim_num_branches                853 # total number of branches committed
sim_elapsed_time                  1 # total simulation time in seconds
sim_inst_rate             7834.0000 # simulation speed (in insts/sec)
sim_total_insn                 7977 # total number of instructions executed
sim_total_refs                 4216 # total number of loads and stores executed
sim_total_loads                 737 # total number of loads executed
sim_total_stores          3479.0000 # total number of stores executed
sim_total_branches              866 # total number of branches executed
sim_cycle                     17537 # total simulation time in cycles
sim_IPC                      0.4467 # instructions per cycle
sim_CPI                      2.2386 # cycles per instruction
sim_exec_BW                  0.4549 # total instructions (mis-spec + committed) per cycle
sim_IPB                      9.1841 # instruction per branch
IFQ_count                     43302 # cumulative IFQ occupancy
IFQ_fcount                    10383 # cumulative IFQ full count
ifq_occupancy                2.4692 # avg IFQ occupancy (insn's)
ifq_rate                     0.4549 # avg IFQ dispatch rate (insn/cycle)
ifq_latency                  5.4284 # avg IFQ occupant latency (cycle's)
ifq_full                     0.5921 # fraction of time (cycle's) IFQ was full
RUU_count                     26524 # cumulative RUU occupancy
RUU_fcount                        0 # cumulative RUU full count
ruu_occupancy                1.5125 # avg RUU occupancy (insn's)
ruu_rate                     0.4549 # avg RUU dispatch rate (insn/cycle)
ruu_latency                  3.3251 # avg RUU occupant latency (cycle's)
ruu_full                     0.0000 # fraction of time (cycle's) RUU was full
LSQ_count                     14143 # cumulative LSQ occupancy
LSQ_fcount                        0 # cumulative LSQ full count
lsq_occupancy                0.8065 # avg LSQ occupancy (insn's)
lsq_rate                     0.4549 # avg LSQ dispatch rate (insn/cycle)
lsq_latency                  1.7730 # avg LSQ occupant latency (cycle's)
lsq_full                     0.0000 # fraction of time (cycle's) LSQ was full
sim_slip                      52493 # total number of slip cycles
avg_sim_slip                 6.7007 # the average slip between issue and retirement
bpred_bimod.lookups             903 # total number of bpred lookups
bpred_bimod.updates             853 # total number of updates
bpred_bimod.addr_hits           668 # total number of address-predicted hits
bpred_bimod.dir_hits            761 # total number of direction-predicted hits (includes addr-hits)
bpred_bimod.misses               92 # total number of misses
bpred_bimod.jr_hits              44 # total number of address-predicted hits for JR's
bpred_bimod.jr_seen              51 # total number of JR's seen
bpred_bimod.jr_non_ras_hits.PP            0 # total number of address-predicted hits for non-RAS JR's
bpred_bimod.jr_non_ras_seen.PP            0 # total number of non-RAS JR's seen
bpred_bimod.bpred_addr_rate    0.7831 # branch address-prediction rate (i.e., addr-hits/updates)
bpred_bimod.bpred_dir_rate    0.8921 # branch direction-prediction rate (i.e., all-hits/updates)
bpred_bimod.bpred_jr_rate    0.8627 # JR address-prediction rate (i.e., JR addr-hits/JRs seen)
bpred_bimod.bpred_jr_non_ras_rate.PP <error: divide by zero> # non-RAS JR addr-pred rate (ie, non-RAS JR hits/JRs seen)
bpred_bimod.retstack_pushes           62 # total number of address pushed onto ret-addr stack
bpred_bimod.retstack_pops           51 # total number of address popped off of ret-addr stack
bpred_bimod.used_ras.PP           51 # total number of RAS predictions used
bpred_bimod.ras_hits.PP           44 # total number of RAS hits
bpred_bimod.ras_rate.PP    0.8627 # RAS prediction rate (i.e., RAS hits/used RAS)
il1.accesses                   8430 # total number of accesses
il1.hits                       8103 # total number of hits
il1.misses                      327 # total number of misses
il1.replacements                 27 # total number of replacements
il1.writebacks                    0 # total number of writebacks
il1.invalidations                 0 # total number of invalidations
il1.miss_rate                0.0388 # miss rate (i.e., misses/ref)
il1.repl_rate                0.0032 # replacement rate (i.e., repls/ref)
il1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
il1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
dl1.accesses                   4175 # total number of accesses
dl1.hits                       3744 # total number of hits
dl1.misses                      431 # total number of misses
dl1.replacements                  1 # total number of replacements
dl1.writebacks                    0 # total number of writebacks
dl1.invalidations                 0 # total number of invalidations
dl1.miss_rate                0.1032 # miss rate (i.e., misses/ref)
dl1.repl_rate                0.0002 # replacement rate (i.e., repls/ref)
dl1.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
dl1.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
ul2.accesses                    758 # total number of accesses
ul2.hits                        357 # total number of hits
ul2.misses                      401 # total number of misses
ul2.replacements                  0 # total number of replacements
ul2.writebacks                    0 # total number of writebacks
ul2.invalidations                 0 # total number of invalidations
ul2.miss_rate                0.5290 # miss rate (i.e., misses/ref)
ul2.repl_rate                0.0000 # replacement rate (i.e., repls/ref)
ul2.wb_rate                  0.0000 # writeback rate (i.e., wrbks/ref)
ul2.inv_rate                 0.0000 # invalidation rate (i.e., invs/ref)
itlb.accesses                  8430 # total number of accesses
itlb.hits                      8424 # total number of hits
itlb.misses                       6 # total number of misses
itlb.replacements                 0 # total number of replacements
itlb.writebacks                   0 # total number of writebacks
itlb.invalidations                0 # total number of invalidations
itlb.miss_rate               0.0007 # miss rate (i.e., misses/ref)
itlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
itlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
itlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
dtlb.accesses                  4175 # total number of accesses
dtlb.hits                      4168 # total number of hits
dtlb.misses                       7 # total number of misses
dtlb.replacements                 0 # total number of replacements
dtlb.writebacks                   0 # total number of writebacks
dtlb.invalidations                0 # total number of invalidations
dtlb.miss_rate               0.0017 # miss rate (i.e., misses/ref)
dtlb.repl_rate               0.0000 # replacement rate (i.e., repls/ref)
dtlb.wb_rate                 0.0000 # writeback rate (i.e., wrbks/ref)
dtlb.inv_rate                0.0000 # invalidation rate (i.e., invs/ref)
sim_invalid_addrs                 0 # total non-speculative bogus addresses seen (debug var)
ld_text_base             0x00400000 # program text (code) segment base
ld_text_size                  23360 # program text (code) size in bytes
ld_data_base             0x10000000 # program initialized data segment base
ld_data_size                   4096 # program init'ed `.data' and uninit'ed `.bss' size in bytes
ld_stack_base            0x7fffc000 # program stack segment base (highest address in stack)
ld_stack_size                 16384 # program initial stack size
ld_prog_entry            0x00400140 # program entry point (initial PC)
ld_environ_base          0x7fff8000 # program environment base address address
ld_target_big_endian              0 # target executable endian-ness, non-zero if big endian
mem.page_count                   13 # total number of pages allocated
mem.page_mem                    52k # total size of memory pages allocated
mem.ptab_misses                  13 # total first level page table misses
mem.ptab_accesses            215340 # total page table accesses
mem.ptab_miss_rate           0.0001 # first level page table miss rate

1) sim_total_insn = 7977

2) sim_cycle = 17537

3) sim_IPC = 0.4467

4) sim_CPI = 2.2386

5) durée = sim_cycle / fréquence = 5.8 mus


exercice 4:

add $s7, $s1, $s1    s7 = s1 + s1
add $s7, $s7, $s7    s7 = s7 + s7
add $s7, $s7, $s3    s7 = s7 + s3
add $s7, $s7, $s3    s7 = s7 + s3
add $s7, $s7, $s2    s7 = s7 + s2

F(X, Y, Z) = 4 * X + 2 * Z + Y


exercice 5:

sub $s7, $s2, $s3    s7 = s2 - s3
add $s7, $s7, $s7    s7 = s7 + s7
add $s7, $s7, $s1    s7 = s7 + s1
sub $s7, $s7, $s3    s7 = s7 - s3

F(X, Y, Z) = 2 * ( Y - Z ) + X - Z


exercice 6:

add $s5, $s6, $s7    0 6 7 5 0 32    00000000 00000110 00000111 00000101 00000000 00100000
and $s6, $s2, $s5    0 2 5 6 0 32    00000000 00000010 00000101 00000110 00000000 00100000
lw $s2, 50($s4)      35 4 2 50       00100011 00000100 00000010 00000000 0000000000110010


exercice 7:

      andi $s3, $s3, 0      s3 = s3 && 0
      andi $s1, $s1, 0      s1 = s1 && 0
      addi $s1, $s1, 1      s1 = s1 + 1
      andi $s11, $s11, 0    s11 + s11 && 0
      andi $s2, $s2, 0      s2 = s2 && 0
      addi $s2, $s2, 10     s2 = s2 + 10
Loop: lw $s8, 0($s5)        s8 = s5[0]
      add $s11, $s11, $s8   s11 = s11 + s8
      addi $s5, $s5, 4      s5 = s5 + 4
      sub $s2, $s2, $s1     s2 = s2 - s1
      bne $s2, $s3, Loop    if ( s2 != s3 ) go to Loop

Ce programme somme 10 valeurs consécutives.
